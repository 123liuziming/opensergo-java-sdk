// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: specification/proto/servicecontract.proto

package com.alibaba.opensergo.api.proto;

public interface FieldOptionsOrBuilder extends
    // @@protoc_insertion_point(interface_extends:opensergo.api.FieldOptions)
    com.google.protobuf.MessageOrBuilder {

  /**
   * <pre>
   * The ctype option instructs the C++ code generator to use a different
   * representation of the field than it normally would.  See the specific
   * options below.  This option is not yet implemented in the open source
   * release -- sorry, we'll try to include it in a future version!
   * </pre>
   *
   * <code>optional .opensergo.api.FieldOptions.CType ctype = 1;</code>
   * @return Whether the ctype field is set.
   */
  boolean hasCtype();
  /**
   * <pre>
   * The ctype option instructs the C++ code generator to use a different
   * representation of the field than it normally would.  See the specific
   * options below.  This option is not yet implemented in the open source
   * release -- sorry, we'll try to include it in a future version!
   * </pre>
   *
   * <code>optional .opensergo.api.FieldOptions.CType ctype = 1;</code>
   * @return The enum numeric value on the wire for ctype.
   */
  int getCtypeValue();
  /**
   * <pre>
   * The ctype option instructs the C++ code generator to use a different
   * representation of the field than it normally would.  See the specific
   * options below.  This option is not yet implemented in the open source
   * release -- sorry, we'll try to include it in a future version!
   * </pre>
   *
   * <code>optional .opensergo.api.FieldOptions.CType ctype = 1;</code>
   * @return The ctype.
   */
  com.alibaba.opensergo.api.proto.FieldOptions.CType getCtype();

  /**
   * <pre>
   * The packed option can be enabled for repeated primitive fields to enable
   * a more efficient representation on the wire. Rather than repeatedly
   * writing the tag and type for each element, the entire array is encoded as
   * a single length-delimited blob. In proto3, only explicit setting it to
   * false will avoid using packed encoding.
   * </pre>
   *
   * <code>optional bool packed = 2;</code>
   * @return Whether the packed field is set.
   */
  boolean hasPacked();
  /**
   * <pre>
   * The packed option can be enabled for repeated primitive fields to enable
   * a more efficient representation on the wire. Rather than repeatedly
   * writing the tag and type for each element, the entire array is encoded as
   * a single length-delimited blob. In proto3, only explicit setting it to
   * false will avoid using packed encoding.
   * </pre>
   *
   * <code>optional bool packed = 2;</code>
   * @return The packed.
   */
  boolean getPacked();

  /**
   * <pre>
   * The jstype option determines the JavaScript type used for values of the
   * field.  The option is permitted only for 64 bit integral and fixed types
   * (int64, uint64, sint64, fixed64, sfixed64).  A field with jstype JS_STRING
   * is represented as JavaScript string, which avoids loss of precision that
   * can happen when a large value is converted to a floating point JavaScript.
   * Specifying JS_NUMBER for the jstype causes the generated JavaScript code to
   * use the JavaScript "number" type.  The behavior of the default option
   * JS_NORMAL is implementation dependent.
   * This option is an enum to permit additional types to be added, e.g.
   * goog.math.Integer.
   * </pre>
   *
   * <code>optional .opensergo.api.FieldOptions.JSType jstype = 6;</code>
   * @return Whether the jstype field is set.
   */
  boolean hasJstype();
  /**
   * <pre>
   * The jstype option determines the JavaScript type used for values of the
   * field.  The option is permitted only for 64 bit integral and fixed types
   * (int64, uint64, sint64, fixed64, sfixed64).  A field with jstype JS_STRING
   * is represented as JavaScript string, which avoids loss of precision that
   * can happen when a large value is converted to a floating point JavaScript.
   * Specifying JS_NUMBER for the jstype causes the generated JavaScript code to
   * use the JavaScript "number" type.  The behavior of the default option
   * JS_NORMAL is implementation dependent.
   * This option is an enum to permit additional types to be added, e.g.
   * goog.math.Integer.
   * </pre>
   *
   * <code>optional .opensergo.api.FieldOptions.JSType jstype = 6;</code>
   * @return The enum numeric value on the wire for jstype.
   */
  int getJstypeValue();
  /**
   * <pre>
   * The jstype option determines the JavaScript type used for values of the
   * field.  The option is permitted only for 64 bit integral and fixed types
   * (int64, uint64, sint64, fixed64, sfixed64).  A field with jstype JS_STRING
   * is represented as JavaScript string, which avoids loss of precision that
   * can happen when a large value is converted to a floating point JavaScript.
   * Specifying JS_NUMBER for the jstype causes the generated JavaScript code to
   * use the JavaScript "number" type.  The behavior of the default option
   * JS_NORMAL is implementation dependent.
   * This option is an enum to permit additional types to be added, e.g.
   * goog.math.Integer.
   * </pre>
   *
   * <code>optional .opensergo.api.FieldOptions.JSType jstype = 6;</code>
   * @return The jstype.
   */
  com.alibaba.opensergo.api.proto.FieldOptions.JSType getJstype();

  /**
   * <pre>
   * Should this field be parsed lazily?  Lazy applies only to message-type
   * fields.  It means that when the outer message is initially parsed, the
   * inner message's contents will not be parsed but instead stored in encoded
   * form.  The inner message will actually be parsed when it is first accessed.
   * This is only a hint.  Implementations are free to choose whether to use
   * eager or lazy parsing regardless of the value of this option.  However,
   * setting this option true suggests that the protocol author believes that
   * using lazy parsing on this field is worth the additional bookkeeping
   * overhead typically needed to implement it.
   * This option does not affect the public interface of any generated code;
   * all method signatures remain the same.  Furthermore, thread-safety of the
   * interface is not affected by this option; const methods remain safe to
   * call from multiple threads concurrently, while non-const methods continue
   * to require exclusive access.
   * Note that implementations may choose not to check required fields within
   * a lazy sub-message.  That is, calling IsInitialized() on the outer message
   * may return true even if the inner message has missing required fields.
   * This is necessary because otherwise the inner message would have to be
   * parsed in order to perform the check, defeating the purpose of lazy
   * parsing.  An implementation which chooses not to check required fields
   * must be consistent about it.  That is, for any particular sub-message, the
   * implementation must either *always* check its required fields, or *never*
   * check its required fields, regardless of whether or not the message has
   * been parsed.
   * As of 2021, lazy does no correctness checks on the byte stream during
   * parsing.  This may lead to crashes if and when an invalid byte stream is
   * finally parsed upon access.
   * TODO(b/211906113):  Enable validation on lazy fields.
   * </pre>
   *
   * <code>optional bool lazy = 5;</code>
   * @return Whether the lazy field is set.
   */
  boolean hasLazy();
  /**
   * <pre>
   * Should this field be parsed lazily?  Lazy applies only to message-type
   * fields.  It means that when the outer message is initially parsed, the
   * inner message's contents will not be parsed but instead stored in encoded
   * form.  The inner message will actually be parsed when it is first accessed.
   * This is only a hint.  Implementations are free to choose whether to use
   * eager or lazy parsing regardless of the value of this option.  However,
   * setting this option true suggests that the protocol author believes that
   * using lazy parsing on this field is worth the additional bookkeeping
   * overhead typically needed to implement it.
   * This option does not affect the public interface of any generated code;
   * all method signatures remain the same.  Furthermore, thread-safety of the
   * interface is not affected by this option; const methods remain safe to
   * call from multiple threads concurrently, while non-const methods continue
   * to require exclusive access.
   * Note that implementations may choose not to check required fields within
   * a lazy sub-message.  That is, calling IsInitialized() on the outer message
   * may return true even if the inner message has missing required fields.
   * This is necessary because otherwise the inner message would have to be
   * parsed in order to perform the check, defeating the purpose of lazy
   * parsing.  An implementation which chooses not to check required fields
   * must be consistent about it.  That is, for any particular sub-message, the
   * implementation must either *always* check its required fields, or *never*
   * check its required fields, regardless of whether or not the message has
   * been parsed.
   * As of 2021, lazy does no correctness checks on the byte stream during
   * parsing.  This may lead to crashes if and when an invalid byte stream is
   * finally parsed upon access.
   * TODO(b/211906113):  Enable validation on lazy fields.
   * </pre>
   *
   * <code>optional bool lazy = 5;</code>
   * @return The lazy.
   */
  boolean getLazy();

  /**
   * <pre>
   * unverified_lazy does no correctness checks on the byte stream. This should
   * only be used where lazy with verification is prohibitive for performance
   * reasons.
   * </pre>
   *
   * <code>optional bool unverified_lazy = 15;</code>
   * @return Whether the unverifiedLazy field is set.
   */
  boolean hasUnverifiedLazy();
  /**
   * <pre>
   * unverified_lazy does no correctness checks on the byte stream. This should
   * only be used where lazy with verification is prohibitive for performance
   * reasons.
   * </pre>
   *
   * <code>optional bool unverified_lazy = 15;</code>
   * @return The unverifiedLazy.
   */
  boolean getUnverifiedLazy();

  /**
   * <pre>
   * Is this field deprecated?
   * Depending on the target platform, this can emit Deprecated annotations
   * for accessors, or it will be completely ignored; in the very least, this
   * is a formalization for deprecating fields.
   * </pre>
   *
   * <code>optional bool deprecated = 3;</code>
   * @return Whether the deprecated field is set.
   */
  boolean hasDeprecated();
  /**
   * <pre>
   * Is this field deprecated?
   * Depending on the target platform, this can emit Deprecated annotations
   * for accessors, or it will be completely ignored; in the very least, this
   * is a formalization for deprecating fields.
   * </pre>
   *
   * <code>optional bool deprecated = 3;</code>
   * @return The deprecated.
   */
  boolean getDeprecated();

  /**
   * <pre>
   * For Google-internal migration only. Do not use.
   * </pre>
   *
   * <code>optional bool weak = 10;</code>
   * @return Whether the weak field is set.
   */
  boolean hasWeak();
  /**
   * <pre>
   * For Google-internal migration only. Do not use.
   * </pre>
   *
   * <code>optional bool weak = 10;</code>
   * @return The weak.
   */
  boolean getWeak();

  /**
   * <pre>
   * The parser stores options it doesn't recognize here. See above.
   * </pre>
   *
   * <code>repeated .opensergo.api.UninterpretedOption uninterpreted_option = 999;</code>
   */
  java.util.List<com.alibaba.opensergo.api.proto.UninterpretedOption> 
      getUninterpretedOptionList();
  /**
   * <pre>
   * The parser stores options it doesn't recognize here. See above.
   * </pre>
   *
   * <code>repeated .opensergo.api.UninterpretedOption uninterpreted_option = 999;</code>
   */
  com.alibaba.opensergo.api.proto.UninterpretedOption getUninterpretedOption(int index);
  /**
   * <pre>
   * The parser stores options it doesn't recognize here. See above.
   * </pre>
   *
   * <code>repeated .opensergo.api.UninterpretedOption uninterpreted_option = 999;</code>
   */
  int getUninterpretedOptionCount();
  /**
   * <pre>
   * The parser stores options it doesn't recognize here. See above.
   * </pre>
   *
   * <code>repeated .opensergo.api.UninterpretedOption uninterpreted_option = 999;</code>
   */
  java.util.List<? extends com.alibaba.opensergo.api.proto.UninterpretedOptionOrBuilder> 
      getUninterpretedOptionOrBuilderList();
  /**
   * <pre>
   * The parser stores options it doesn't recognize here. See above.
   * </pre>
   *
   * <code>repeated .opensergo.api.UninterpretedOption uninterpreted_option = 999;</code>
   */
  com.alibaba.opensergo.api.proto.UninterpretedOptionOrBuilder getUninterpretedOptionOrBuilder(
      int index);
}
